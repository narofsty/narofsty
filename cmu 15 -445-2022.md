# cmu 15 -445    (BusTub repository)

## 项目目标：

将会实现一个键值存储通过一个concurrent trie.  并行查找

trie  是一个效率高的有序树数据结构



## 实现

修改   p0_trie.h      路径： src/include/primer/p0_trie.h   

函数语法和成员变量的实现。实现所有的构造和析构函数和成员函数。

## 任 务 #1-d

三个类的实现。

### TrieNode Class

```
TrieNode Class

TrieNode(TrieNode &&other_trie_node)

InsertChildNode  GetChildNode
```

### TrieNodeWithValue Class

```
TrieNodeWithValue Class

TrieNodeWithValue  继承TrieNode  ,并且代表了一个中止节点， 可以代表任意的类型 T的值，  它的 is_end_ flag 永远是正确的。

当你通过有序树迭代（iterate）找到一个给定的键并且到达结尾字符，将会从这个类调用不同的构造函数，在不同的方案。
TrieNodeWithValue(char key_char, T value)
创造一个新的节点，给的字符和值。
TrieNodeWithValue(TrieNode &&trieNode, T value)
将它自己的 value_ 设置为给定的值
```

### Trie Class

```
Trie 类定义了真实的trie,支持插入，查找，删除操作。树的root节点是所有节点的开始节点并且他自己不存储任何的字符。

>>Insert
插入节点首先根据给定的键要遍历整trie,如果不存在则插入它。并且重复的键是不被允许插入的，返回false.
>>>>到达键的结束字符
1.TrieNode 不存在，调用   TrieNodeWithValue(char key_char, T value) 

2.  is_end==false  ~~~ 不是终止节点     代表的是  unique_ptr 指向的是TriNode,但不是一个 TrieNodeWithValue 对象
调用  TrieNodeWithValue(TrieNode &&trieNode, T value)  构造函数将旧的TrieNode 转变为新的TrieNodeWithValue

3.  is_end==true  节点已经存在并且是一个终止节点。  

>> remove
1.遍历给定的键，不存在 立即返回
2.将终端节点的 is_end 标志切换为false
3.节点不存在孩子，删除它调用它的双亲的  children_ 
4.遍历递归删除没有孩子的节点，遇到有孩子节点就停止

>>get value
给一个键，返回它对应T类型值
1.key 没有  ，  type  没有，success =false;
2.检查类型是否相同，  dynamic_cast   Tried  ->    TrieNodeWithValue<T>   casted is nullptr,就是不符合的。
```

## Task #2 -CONCURRENT   TRIE   并行

多线程环境运行

**Rwlatch**  Bus Tub's implentation of readers-writer lock         ,Rwlatch     -----unlock

**std::shared_mutex**

在根节点上获取读/写锁实现简单的并发控制

**Getvalue**    read         调用RwLatch  的RLock方法

**insert/remove**               `RwLatch`'s `Wlock` method



